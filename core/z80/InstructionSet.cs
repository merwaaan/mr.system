using System;
using System.Linq;

namespace mr.system {

  public class InstructionSet {

    private readonly CPU cpu;
    private readonly Instruction[] main;
    private readonly Instruction[] ed;

    public class UnimplementedInstructionException: Exception {
      
      public UnimplementedInstructionException(byte opcode)
        : base($"Opcode {opcode.ToString("X2")} not implemented") { }
    
      public UnimplementedInstructionException(byte prefix, byte opcode)
        : base($"Opcode [{prefix.ToString("X2")}] {opcode.ToString("X2")} not implemented") { }
    }

    public Instruction GetCurrent() {
      Instruction instruction = null;

      byte opcode = cpu.AtPC();
      switch (opcode) {
        case 0xED: instruction = ed[cpu.AtPC(1)]; break;
        default: instruction = main[opcode]; break;
      }

      if (instruction == null)
        throw Utils.IsPrefix(opcode) ?
          new UnimplementedInstructionException(opcode, cpu.AtPC(1)) :
          new UnimplementedInstructionException(opcode);

      return instruction;
    }
    
    public string Disassembled() {
      Instruction instruction = GetCurrent();
      Operand[] operands = instruction.Operands;

      if (operands.Length == 0)
        return $"{instruction.info.mnemonics}";

      string[] parts = instruction.info.mnemonics.Split(' ');
      string instructionName = parts[0];
      string[] operandNames = parts[1].Split(',');

      var pairs = instruction.Operands.Select(o => o.ToString())
                                      .Zip(operandNames, (operand, name) => $"{name}[={operand}]");

      return $"{instructionName} {string.Join(",", pairs)}";
    }

    public InstructionSet(CPU cpu) {
      this.cpu = cpu;

      // GENERATED CODE STARTS HERE
      main = new Instruction[] {
        new Instruction(cpu, 0x00, "nop", "No operation is performed.", 1, 4, Instructions.nop(cpu)),
        new Instruction(cpu, 0x01, "ld bc,**", "Loads ** into bc.", 3, 10, Instructions.ld(cpu, new Register16(cpu, "bc"), new Immediate16(cpu))),
        new Instruction(cpu, 0x02, "ld (bc),a", "Stores a into the memory location pointed to by bc.", 1, 7, Instructions.ld(cpu, new Indirect8(cpu, new Register16(cpu, "bc")), new Register8(cpu, "a"))),
        new Instruction(cpu, 0x03, "inc bc", "Adds one to bc.", 1, 6, Instructions.inc(cpu, new Register16(cpu, "bc"))),
        new Instruction(cpu, 0x04, "inc b", "Adds one to b.", 1, 4, Instructions.inc(cpu, new Register8(cpu, "b"))),
        new Instruction(cpu, 0x05, "dec b", "Subtracts one from b.", 1, 4, Instructions.dec(cpu, new Register8(cpu, "b"))),
        new Instruction(cpu, 0x06, "ld b,*", "Loads * into b.", 2, 7, Instructions.ld(cpu, new Register8(cpu, "b"), new Immediate8(cpu))),
        new Instruction(cpu, 0x07, "rlca", "The contents of a are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.", 1, 4, Instructions.rlca(cpu)),
        new Instruction(cpu, 0x08, "ex af,af_", "Exchanges the 16-bit contents of af and af'.", 1, 4, Instructions.ex(cpu, new Register16(cpu, "af"), new Register16(cpu, "af" /* TODO alt! */))),
        new Instruction(cpu, 0x09, "add hl,bc", "The value of bc is added to hl.", 1, 11, Instructions.add(cpu, new Register16(cpu, "hl"), new Register16(cpu, "bc"))),
        new Instruction(cpu, 0x0A, "ld a,(bc)", "Loads the value pointed to by bc into a.", 1, 7, Instructions.ld(cpu, new Register8(cpu, "a"), new Indirect8(cpu, new Register16(cpu, "bc")))),
        new Instruction(cpu, 0x0B, "dec bc", "Subtracts one from bc.", 1, 6, Instructions.dec(cpu, new Register16(cpu, "bc"))),
        new Instruction(cpu, 0x0C, "inc c", "Adds one to c.", 1, 4, Instructions.inc(cpu, new Register8(cpu, "c"))),
        new Instruction(cpu, 0x0D, "dec c", "Subtracts one from c.", 1, 4, Instructions.dec(cpu, new Register8(cpu, "c"))),
        new Instruction(cpu, 0x0E, "ld c,*", "Loads * into c.", 2, 7, Instructions.ld(cpu, new Register8(cpu, "c"), new Immediate8(cpu))),
        new Instruction(cpu, 0x0F, "rrca", "The contents of a are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.", 1, 4, Instructions.rrca(cpu)),
        new Instruction(cpu, 0x10, "djnz *", "The b register is decremented, and if not zero, the signed value * is added to pc. The jump is measured from the start of the instruction opcode.", 2, 13, Instructions.djnz(cpu, new Immediate8(cpu))),
        new Instruction(cpu, 0x11, "ld de,**", "Loads ** into de.", 3, 10, Instructions.ld(cpu, new Register16(cpu, "de"), new Immediate16(cpu))),
        new Instruction(cpu, 0x12, "ld (de),a", "Stores a into the memory location pointed to by de.", 1, 7, Instructions.ld(cpu, new Indirect8(cpu, new Register16(cpu, "de")), new Register8(cpu, "a"))),
        new Instruction(cpu, 0x13, "inc de", "Adds one to de.", 1, 6, Instructions.inc(cpu, new Register16(cpu, "de"))),
        new Instruction(cpu, 0x14, "inc d", "Adds one to d.", 1, 4, Instructions.inc(cpu, new Register8(cpu, "d"))),
        new Instruction(cpu, 0x15, "dec d", "Subtracts one from d.", 1, 4, Instructions.dec(cpu, new Register8(cpu, "d"))),
        new Instruction(cpu, 0x16, "ld d,*", "Loads * into d.", 2, 7, Instructions.ld(cpu, new Register8(cpu, "d"), new Immediate8(cpu))),
        new Instruction(cpu, 0x17, "rla", "The contents of a are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.", 1, 4, Instructions.rla(cpu)),
        new Instruction(cpu, 0x18, "jr *", "The signed value * is added to pc. The jump is measured from the start of the instruction opcode.", 2, 12, Instructions.jr(cpu, new Immediate8(cpu))),
        new Instruction(cpu, 0x19, "add hl,de", "The value of de is added to hl.", 1, 11, Instructions.add(cpu, new Register16(cpu, "hl"), new Register16(cpu, "de"))),
        new Instruction(cpu, 0x1A, "ld a,(de)", "Loads the value pointed to by de into a.", 1, 7, Instructions.ld(cpu, new Register8(cpu, "a"), new Indirect8(cpu, new Register16(cpu, "de")))),
        new Instruction(cpu, 0x1B, "dec de", "Subtracts one from de.", 1, 6, Instructions.dec(cpu, new Register16(cpu, "de"))),
        new Instruction(cpu, 0x1C, "inc e", "Adds one to e.", 1, 4, Instructions.inc(cpu, new Register8(cpu, "e"))),
        new Instruction(cpu, 0x1D, "dec e", "Subtracts one from e.", 1, 4, Instructions.dec(cpu, new Register8(cpu, "e"))),
        new Instruction(cpu, 0x1E, "ld e,*", "Loads * into e.", 2, 7, Instructions.ld(cpu, new Register8(cpu, "e"), new Immediate8(cpu))),
        new Instruction(cpu, 0x1F, "rra", "The contents of a are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.", 1, 4, Instructions.rra(cpu)),
        new Instruction(cpu, 0x20, "jr f_nz,*", "If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode.", 2, 12, Instructions.jr(cpu, new FlagCondition(cpu, "zero", false), new Immediate8(cpu))),
        new Instruction(cpu, 0x21, "ld hl,**", "Loads ** into hl.", 3, 10, Instructions.ld(cpu, new Register16(cpu, "hl"), new Immediate16(cpu))),
        new Instruction(cpu, 0x22, "ld (**),hl", "Stores hl into the memory location pointed to by **.", 3, 16, Instructions.ld(cpu, new Indirect16(cpu, new Immediate16(cpu)), new Register16(cpu, "hl"))),
        new Instruction(cpu, 0x23, "inc hl", "Adds one to hl.", 1, 6, Instructions.inc(cpu, new Register16(cpu, "hl"))),
        new Instruction(cpu, 0x24, "inc h", "Adds one to h.", 1, 4, Instructions.inc(cpu, new Register8(cpu, "h"))),
        new Instruction(cpu, 0x25, "dec h", "Subtracts one from h.", 1, 4, Instructions.dec(cpu, new Register8(cpu, "h"))),
        new Instruction(cpu, 0x26, "ld h,*", "Loads * into h.", 2, 7, Instructions.ld(cpu, new Register8(cpu, "h"), new Immediate8(cpu))),
        null,
        new Instruction(cpu, 0x28, "jr f_z,*", "If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode.", 2, 12, Instructions.jr(cpu, new FlagCondition(cpu, "zero", true), new Immediate8(cpu))),
        new Instruction(cpu, 0x29, "add hl,hl", "The value of hl is added to hl.", 1, 11, Instructions.add(cpu, new Register16(cpu, "hl"), new Register16(cpu, "hl"))),
        new Instruction(cpu, 0x2A, "ld hl,(**)", "Loads the value pointed to by ** into hl.", 3, 16, Instructions.ld(cpu, new Register16(cpu, "hl"), new Indirect16(cpu, new Immediate16(cpu)))),
        new Instruction(cpu, 0x2B, "dec hl", "Subtracts one from hl.", 1, 6, Instructions.dec(cpu, new Register16(cpu, "hl"))),
        new Instruction(cpu, 0x2C, "inc l", "Adds one to l.", 1, 4, Instructions.inc(cpu, new Register8(cpu, "l"))),
        new Instruction(cpu, 0x2D, "dec l", "Subtracts one from l.", 1, 4, Instructions.dec(cpu, new Register8(cpu, "l"))),
        new Instruction(cpu, 0x2E, "ld l,*", "Loads * into l.", 2, 7, Instructions.ld(cpu, new Register8(cpu, "l"), new Immediate8(cpu))),
        new Instruction(cpu, 0x2F, "cpl", "The contents of a are inverted (one's complement).", 1, 4, Instructions.cpl(cpu)),
        new Instruction(cpu, 0x30, "jr f_nc,*", "If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode.", 2, 12, Instructions.jr(cpu, new FlagCondition(cpu, "carry", false), new Immediate8(cpu))),
        new Instruction(cpu, 0x31, "ld sp,**", "Loads ** into sp.", 3, 10, Instructions.ld(cpu, new Register16(cpu, "sp"), new Immediate16(cpu))),
        new Instruction(cpu, 0x32, "ld (**),a", "Stores a into the memory location pointed to by **.", 3, 13, Instructions.ld(cpu, new Indirect8(cpu, new Immediate16(cpu)), new Register8(cpu, "a"))),
        new Instruction(cpu, 0x33, "inc sp", "Adds one to sp.", 1, 6, Instructions.inc(cpu, new Register16(cpu, "sp"))),
        new Instruction(cpu, 0x34, "inc (hl)", "Adds one to (hl).", 1, 11, Instructions.inc(cpu, new Indirect8(cpu, new Register16(cpu, "hl")))),
        new Instruction(cpu, 0x35, "dec (hl)", "Subtracts one from (hl).", 1, 11, Instructions.dec(cpu, new Indirect8(cpu, new Register16(cpu, "hl")))),
        new Instruction(cpu, 0x36, "ld (hl),*", "Loads * into (hl).", 2, 10, Instructions.ld(cpu, new Indirect8(cpu, new Register16(cpu, "hl")), new Immediate8(cpu))),
        null,
        new Instruction(cpu, 0x38, "jr f_c,*", "If condition cc is true, the signed value * is added to pc. The jump is measured from the start of the instruction opcode.", 2, 12, Instructions.jr(cpu, new FlagCondition(cpu, "carry", true), new Immediate8(cpu))),
        new Instruction(cpu, 0x39, "add hl,sp", "The value of hl is added to hl.", 1, 11, Instructions.add(cpu, new Register16(cpu, "hl"), new Register16(cpu, "sp"))),
        new Instruction(cpu, 0x3A, "ld a,(**)", "Loads the value pointed to by ** into a.", 3, 13, Instructions.ld(cpu, new Register8(cpu, "a"), new Indirect8(cpu, new Immediate16(cpu)))),
        new Instruction(cpu, 0x3B, "dec sp", "Subtracts one from sp.", 1, 6, Instructions.dec(cpu, new Register16(cpu, "sp"))),
        new Instruction(cpu, 0x3C, "inc a", "Adds one to a.", 1, 4, Instructions.inc(cpu, new Register8(cpu, "a"))),
        new Instruction(cpu, 0x3D, "dec a", "Subtracts one from a.", 1, 4, Instructions.dec(cpu, new Register8(cpu, "a"))),
        new Instruction(cpu, 0x3E, "ld a,*", "Loads * into a.", 2, 7, Instructions.ld(cpu, new Register8(cpu, "a"), new Immediate8(cpu))),
        null,
        new Instruction(cpu, 0x40, "ld b,b", "The contents of b are loaded into b.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "b"), new Register8(cpu, "b"))),
        new Instruction(cpu, 0x41, "ld b,c", "The contents of c are loaded into b.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "b"), new Register8(cpu, "c"))),
        new Instruction(cpu, 0x42, "ld b,d", "The contents of d are loaded into b.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "b"), new Register8(cpu, "d"))),
        new Instruction(cpu, 0x43, "ld b,e", "The contents of e are loaded into b.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "b"), new Register8(cpu, "e"))),
        new Instruction(cpu, 0x44, "ld b,h", "The contents of h are loaded into b.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "b"), new Register8(cpu, "h"))),
        new Instruction(cpu, 0x45, "ld b,l", "The contents of l are loaded into b.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "b"), new Register8(cpu, "l"))),
        new Instruction(cpu, 0x46, "ld b,(hl)", "The contents of (hl) are loaded into b.", 1, 7, Instructions.ld(cpu, new Register8(cpu, "b"), new Indirect8(cpu, new Register16(cpu, "hl")))),
        new Instruction(cpu, 0x47, "ld b,a", "The contents of a are loaded into b.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "b"), new Register8(cpu, "a"))),
        new Instruction(cpu, 0x48, "ld c,b", "The contents of b are loaded into c.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "c"), new Register8(cpu, "b"))),
        new Instruction(cpu, 0x49, "ld c,c", "The contents of c are loaded into c.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "c"), new Register8(cpu, "c"))),
        new Instruction(cpu, 0x4A, "ld c,d", "The contents of d are loaded into c.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "c"), new Register8(cpu, "d"))),
        new Instruction(cpu, 0x4B, "ld c,e", "The contents of e are loaded into c.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "c"), new Register8(cpu, "e"))),
        new Instruction(cpu, 0x4C, "ld c,h", "The contents of h are loaded into c.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "c"), new Register8(cpu, "h"))),
        new Instruction(cpu, 0x4D, "ld c,l", "The contents of l are loaded into c.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "c"), new Register8(cpu, "l"))),
        new Instruction(cpu, 0x4E, "ld c,(hl)", "The contents of (hl) are loaded into c.", 1, 7, Instructions.ld(cpu, new Register8(cpu, "c"), new Indirect8(cpu, new Register16(cpu, "hl")))),
        new Instruction(cpu, 0x4F, "ld c,a", "The contents of a are loaded into c.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "c"), new Register8(cpu, "a"))),
        new Instruction(cpu, 0x50, "ld d,b", "The contents of b are loaded into d.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "d"), new Register8(cpu, "b"))),
        new Instruction(cpu, 0x51, "ld d,c", "The contents of c are loaded into d.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "d"), new Register8(cpu, "c"))),
        new Instruction(cpu, 0x52, "ld d,d", "The contents of d are loaded into d.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "d"), new Register8(cpu, "d"))),
        new Instruction(cpu, 0x53, "ld d,e", "The contents of e are loaded into d.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "d"), new Register8(cpu, "e"))),
        new Instruction(cpu, 0x54, "ld d,h", "The contents of h are loaded into d.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "d"), new Register8(cpu, "h"))),
        new Instruction(cpu, 0x55, "ld d,l", "The contents of l are loaded into d.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "d"), new Register8(cpu, "l"))),
        new Instruction(cpu, 0x56, "ld d,(hl)", "The contents of (hl) are loaded into d.", 1, 7, Instructions.ld(cpu, new Register8(cpu, "d"), new Indirect8(cpu, new Register16(cpu, "hl")))),
        new Instruction(cpu, 0x57, "ld d,a", "The contents of a are loaded into d.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "d"), new Register8(cpu, "a"))),
        new Instruction(cpu, 0x58, "ld e,b", "The contents of b are loaded into e.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "e"), new Register8(cpu, "b"))),
        new Instruction(cpu, 0x59, "ld e,c", "The contents of c are loaded into e.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "e"), new Register8(cpu, "c"))),
        new Instruction(cpu, 0x5A, "ld e,d", "The contents of d are loaded into e.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "e"), new Register8(cpu, "d"))),
        new Instruction(cpu, 0x5B, "ld e,e", "The contents of e are loaded into e.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "e"), new Register8(cpu, "e"))),
        new Instruction(cpu, 0x5C, "ld e,h", "The contents of h are loaded into e.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "e"), new Register8(cpu, "h"))),
        new Instruction(cpu, 0x5D, "ld e,l", "The contents of l are loaded into e.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "e"), new Register8(cpu, "l"))),
        new Instruction(cpu, 0x5E, "ld e,(hl)", "The contents of (hl) are loaded into e.", 1, 7, Instructions.ld(cpu, new Register8(cpu, "e"), new Indirect8(cpu, new Register16(cpu, "hl")))),
        new Instruction(cpu, 0x5F, "ld e,a", "The contents of a are loaded into e.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "e"), new Register8(cpu, "a"))),
        new Instruction(cpu, 0x60, "ld h,b", "The contents of b are loaded into h.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "h"), new Register8(cpu, "b"))),
        new Instruction(cpu, 0x61, "ld h,c", "The contents of c are loaded into h.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "h"), new Register8(cpu, "c"))),
        new Instruction(cpu, 0x62, "ld h,d", "The contents of d are loaded into h.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "h"), new Register8(cpu, "d"))),
        new Instruction(cpu, 0x63, "ld h,e", "The contents of e are loaded into h.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "h"), new Register8(cpu, "e"))),
        new Instruction(cpu, 0x64, "ld h,h", "The contents of h are loaded into h.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "h"), new Register8(cpu, "h"))),
        new Instruction(cpu, 0x65, "ld h,l", "The contents of l are loaded into h.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "h"), new Register8(cpu, "l"))),
        new Instruction(cpu, 0x66, "ld h,(hl)", "The contents of (hl) are loaded into h.", 1, 7, Instructions.ld(cpu, new Register8(cpu, "h"), new Indirect8(cpu, new Register16(cpu, "hl")))),
        new Instruction(cpu, 0x67, "ld h,a", "The contents of a are loaded into h.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "h"), new Register8(cpu, "a"))),
        new Instruction(cpu, 0x68, "ld l,b", "The contents of b are loaded into l.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "l"), new Register8(cpu, "b"))),
        new Instruction(cpu, 0x69, "ld l,c", "The contents of c are loaded into l.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "l"), new Register8(cpu, "c"))),
        new Instruction(cpu, 0x6A, "ld l,d", "The contents of d are loaded into l.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "l"), new Register8(cpu, "d"))),
        new Instruction(cpu, 0x6B, "ld l,e", "The contents of e are loaded into l.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "l"), new Register8(cpu, "e"))),
        new Instruction(cpu, 0x6C, "ld l,h", "The contents of h are loaded into l.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "l"), new Register8(cpu, "h"))),
        new Instruction(cpu, 0x6D, "ld l,l", "The contents of l are loaded into l.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "l"), new Register8(cpu, "l"))),
        new Instruction(cpu, 0x6E, "ld l,(hl)", "The contents of (hl) are loaded into l.", 1, 7, Instructions.ld(cpu, new Register8(cpu, "l"), new Indirect8(cpu, new Register16(cpu, "hl")))),
        new Instruction(cpu, 0x6F, "ld l,a", "The contents of a are loaded into l.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "l"), new Register8(cpu, "a"))),
        new Instruction(cpu, 0x70, "ld (hl),b", "The contents of b are loaded into (hl).", 1, 7, Instructions.ld(cpu, new Indirect8(cpu, new Register16(cpu, "hl")), new Register8(cpu, "b"))),
        new Instruction(cpu, 0x71, "ld (hl),c", "The contents of c are loaded into (hl).", 1, 7, Instructions.ld(cpu, new Indirect8(cpu, new Register16(cpu, "hl")), new Register8(cpu, "c"))),
        new Instruction(cpu, 0x72, "ld (hl),d", "The contents of d are loaded into (hl).", 1, 7, Instructions.ld(cpu, new Indirect8(cpu, new Register16(cpu, "hl")), new Register8(cpu, "d"))),
        new Instruction(cpu, 0x73, "ld (hl),e", "The contents of e are loaded into (hl).", 1, 7, Instructions.ld(cpu, new Indirect8(cpu, new Register16(cpu, "hl")), new Register8(cpu, "e"))),
        new Instruction(cpu, 0x74, "ld (hl),h", "The contents of h are loaded into (hl).", 1, 7, Instructions.ld(cpu, new Indirect8(cpu, new Register16(cpu, "hl")), new Register8(cpu, "h"))),
        new Instruction(cpu, 0x75, "ld (hl),l", "The contents of l are loaded into (hl).", 1, 7, Instructions.ld(cpu, new Indirect8(cpu, new Register16(cpu, "hl")), new Register8(cpu, "l"))),
        new Instruction(cpu, 0x76, "halt", "Suspends CPU operation until an interrupt or reset occurs.", 1, 4, Instructions.halt(cpu)),
        new Instruction(cpu, 0x77, "ld (hl),a", "The contents of a are loaded into (hl).", 1, 7, Instructions.ld(cpu, new Indirect8(cpu, new Register16(cpu, "hl")), new Register8(cpu, "a"))),
        new Instruction(cpu, 0x78, "ld a,b", "The contents of b are loaded into a.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "a"), new Register8(cpu, "b"))),
        new Instruction(cpu, 0x79, "ld a,c", "The contents of c are loaded into a.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "a"), new Register8(cpu, "c"))),
        new Instruction(cpu, 0x7A, "ld a,d", "The contents of d are loaded into a.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "a"), new Register8(cpu, "d"))),
        new Instruction(cpu, 0x7B, "ld a,e", "The contents of e are loaded into a.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "a"), new Register8(cpu, "e"))),
        new Instruction(cpu, 0x7C, "ld a,h", "The contents of h are loaded into a.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "a"), new Register8(cpu, "h"))),
        new Instruction(cpu, 0x7D, "ld a,l", "The contents of l are loaded into a.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "a"), new Register8(cpu, "l"))),
        new Instruction(cpu, 0x7E, "ld a,(hl)", "The contents of (hl) are loaded into a.", 1, 7, Instructions.ld(cpu, new Register8(cpu, "a"), new Indirect8(cpu, new Register16(cpu, "hl")))),
        new Instruction(cpu, 0x7F, "ld a,a", "The contents of a are loaded into a.", 1, 4, Instructions.ld(cpu, new Register8(cpu, "a"), new Register8(cpu, "a"))),
        new Instruction(cpu, 0x80, "add a,b", "Adds b to a.", 1, 4, Instructions.add(cpu, new Register8(cpu, "a"), new Register8(cpu, "b"))),
        new Instruction(cpu, 0x81, "add a,c", "Adds c to a.", 1, 4, Instructions.add(cpu, new Register8(cpu, "a"), new Register8(cpu, "c"))),
        new Instruction(cpu, 0x82, "add a,d", "Adds d to a.", 1, 4, Instructions.add(cpu, new Register8(cpu, "a"), new Register8(cpu, "d"))),
        new Instruction(cpu, 0x83, "add a,e", "Adds e to a.", 1, 4, Instructions.add(cpu, new Register8(cpu, "a"), new Register8(cpu, "e"))),
        new Instruction(cpu, 0x84, "add a,h", "Adds h to a.", 1, 4, Instructions.add(cpu, new Register8(cpu, "a"), new Register8(cpu, "h"))),
        new Instruction(cpu, 0x85, "add a,l", "Adds l to a.", 1, 4, Instructions.add(cpu, new Register8(cpu, "a"), new Register8(cpu, "l"))),
        new Instruction(cpu, 0x86, "add a,(hl)", "Adds (hl) to a.", 1, 7, Instructions.add(cpu, new Register8(cpu, "a"), new Indirect8(cpu, new Register16(cpu, "hl")))),
        new Instruction(cpu, 0x87, "add a,a", "Adds a to a.", 1, 4, Instructions.add(cpu, new Register8(cpu, "a"), new Register8(cpu, "a"))),
        new Instruction(cpu, 0x88, "adc a,b", "Adds b and the carry flag to a.", 1, 4, Instructions.adc(cpu, new Register8(cpu, "a"), new Register8(cpu, "b"))),
        new Instruction(cpu, 0x89, "adc a,c", "Adds c and the carry flag to a.", 1, 4, Instructions.adc(cpu, new Register8(cpu, "a"), new Register8(cpu, "c"))),
        new Instruction(cpu, 0x8A, "adc a,d", "Adds d and the carry flag to a.", 1, 4, Instructions.adc(cpu, new Register8(cpu, "a"), new Register8(cpu, "d"))),
        new Instruction(cpu, 0x8B, "adc a,e", "Adds e and the carry flag to a.", 1, 4, Instructions.adc(cpu, new Register8(cpu, "a"), new Register8(cpu, "e"))),
        new Instruction(cpu, 0x8C, "adc a,h", "Adds h and the carry flag to a.", 1, 4, Instructions.adc(cpu, new Register8(cpu, "a"), new Register8(cpu, "h"))),
        new Instruction(cpu, 0x8D, "adc a,l", "Adds l and the carry flag to a.", 1, 4, Instructions.adc(cpu, new Register8(cpu, "a"), new Register8(cpu, "l"))),
        new Instruction(cpu, 0x8E, "adc a,(hl)", "Adds (hl) and the carry flag to a.", 1, 7, Instructions.adc(cpu, new Register8(cpu, "a"), new Indirect8(cpu, new Register16(cpu, "hl")))),
        new Instruction(cpu, 0x8F, "adc a,a", "Adds a and the carry flag to a.", 1, 4, Instructions.adc(cpu, new Register8(cpu, "a"), new Register8(cpu, "a"))),
        new Instruction(cpu, 0x90, "sub b", "Subtracts b from a.", 1, 4, Instructions.sub(cpu, new Register8(cpu, "b"))),
        new Instruction(cpu, 0x91, "sub c", "Subtracts c from a.", 1, 4, Instructions.sub(cpu, new Register8(cpu, "c"))),
        new Instruction(cpu, 0x92, "sub d", "Subtracts d from a.", 1, 4, Instructions.sub(cpu, new Register8(cpu, "d"))),
        new Instruction(cpu, 0x93, "sub e", "Subtracts e from a.", 1, 4, Instructions.sub(cpu, new Register8(cpu, "e"))),
        new Instruction(cpu, 0x94, "sub h", "Subtracts h from a.", 1, 4, Instructions.sub(cpu, new Register8(cpu, "h"))),
        new Instruction(cpu, 0x95, "sub l", "Subtracts l from a.", 1, 4, Instructions.sub(cpu, new Register8(cpu, "l"))),
        new Instruction(cpu, 0x96, "sub (hl)", "Subtracts (hl) from a.", 1, 7, Instructions.sub(cpu, new Indirect8(cpu, new Register16(cpu, "hl")))),
        new Instruction(cpu, 0x97, "sub a", "Subtracts a from a.", 1, 4, Instructions.sub(cpu, new Register8(cpu, "a"))),
        new Instruction(cpu, 0x98, "sbc a,b", "Subtracts b and the carry flag from a.", 1, 4, Instructions.sbc(cpu, new Register8(cpu, "a"), new Register8(cpu, "b"))),
        new Instruction(cpu, 0x99, "sbc a,c", "Subtracts c and the carry flag from a.", 1, 4, Instructions.sbc(cpu, new Register8(cpu, "a"), new Register8(cpu, "c"))),
        new Instruction(cpu, 0x9A, "sbc a,d", "Subtracts d and the carry flag from a.", 1, 4, Instructions.sbc(cpu, new Register8(cpu, "a"), new Register8(cpu, "d"))),
        new Instruction(cpu, 0x9B, "sbc a,e", "Subtracts e and the carry flag from a.", 1, 4, Instructions.sbc(cpu, new Register8(cpu, "a"), new Register8(cpu, "e"))),
        new Instruction(cpu, 0x9C, "sbc a,h", "Subtracts h and the carry flag from a.", 1, 4, Instructions.sbc(cpu, new Register8(cpu, "a"), new Register8(cpu, "h"))),
        new Instruction(cpu, 0x9D, "sbc a,l", "Subtracts l and the carry flag from a.", 1, 4, Instructions.sbc(cpu, new Register8(cpu, "a"), new Register8(cpu, "l"))),
        new Instruction(cpu, 0x9E, "sbc a,(hl)", "Subtracts (hl) and the carry flag from a.", 1, 7, Instructions.sbc(cpu, new Register8(cpu, "a"), new Indirect8(cpu, new Register16(cpu, "hl")))),
        new Instruction(cpu, 0x9F, "sbc a,a", "Subtracts a and the carry flag from a.", 1, 4, Instructions.sbc(cpu, new Register8(cpu, "a"), new Register8(cpu, "a"))),
        new Instruction(cpu, 0xA0, "and b", "Bitwise AND on a with b.", 1, 4, Instructions.and(cpu, new Register8(cpu, "b"))),
        new Instruction(cpu, 0xA1, "and c", "Bitwise AND on a with c.", 1, 4, Instructions.and(cpu, new Register8(cpu, "c"))),
        new Instruction(cpu, 0xA2, "and d", "Bitwise AND on a with d.", 1, 4, Instructions.and(cpu, new Register8(cpu, "d"))),
        new Instruction(cpu, 0xA3, "and e", "Bitwise AND on a with e.", 1, 4, Instructions.and(cpu, new Register8(cpu, "e"))),
        new Instruction(cpu, 0xA4, "and h", "Bitwise AND on a with h.", 1, 4, Instructions.and(cpu, new Register8(cpu, "h"))),
        new Instruction(cpu, 0xA5, "and l", "Bitwise AND on a with l.", 1, 4, Instructions.and(cpu, new Register8(cpu, "l"))),
        new Instruction(cpu, 0xA6, "and (hl)", "Bitwise AND on a with (hl).", 1, 7, Instructions.and(cpu, new Indirect8(cpu, new Register16(cpu, "hl")))),
        new Instruction(cpu, 0xA7, "and a", "Bitwise AND on a with a.", 1, 4, Instructions.and(cpu, new Register8(cpu, "a"))),
        new Instruction(cpu, 0xA8, "xor b", "Bitwise XOR on a with b.", 1, 4, Instructions.xor(cpu, new Register8(cpu, "b"))),
        new Instruction(cpu, 0xA9, "xor c", "Bitwise XOR on a with c.", 1, 4, Instructions.xor(cpu, new Register8(cpu, "c"))),
        new Instruction(cpu, 0xAA, "xor d", "Bitwise XOR on a with d.", 1, 4, Instructions.xor(cpu, new Register8(cpu, "d"))),
        new Instruction(cpu, 0xAB, "xor e", "Bitwise XOR on a with e.", 1, 4, Instructions.xor(cpu, new Register8(cpu, "e"))),
        new Instruction(cpu, 0xAC, "xor h", "Bitwise XOR on a with h.", 1, 4, Instructions.xor(cpu, new Register8(cpu, "h"))),
        new Instruction(cpu, 0xAD, "xor l", "Bitwise XOR on a with l.", 1, 4, Instructions.xor(cpu, new Register8(cpu, "l"))),
        new Instruction(cpu, 0xAE, "xor (hl)", "Bitwise XOR on a with (hl).", 1, 7, Instructions.xor(cpu, new Indirect8(cpu, new Register16(cpu, "hl")))),
        new Instruction(cpu, 0xAF, "xor a", "Bitwise XOR on a with a.", 1, 4, Instructions.xor(cpu, new Register8(cpu, "a"))),
        new Instruction(cpu, 0xB0, "or b", "Bitwise OR on a with b.", 1, 4, Instructions.or(cpu, new Register8(cpu, "b"))),
        new Instruction(cpu, 0xB1, "or c", "Bitwise OR on a with c.", 1, 4, Instructions.or(cpu, new Register8(cpu, "c"))),
        new Instruction(cpu, 0xB2, "or d", "Bitwise OR on a with d.", 1, 4, Instructions.or(cpu, new Register8(cpu, "d"))),
        new Instruction(cpu, 0xB3, "or e", "Bitwise OR on a with e.", 1, 4, Instructions.or(cpu, new Register8(cpu, "e"))),
        new Instruction(cpu, 0xB4, "or h", "Bitwise OR on a with h.", 1, 4, Instructions.or(cpu, new Register8(cpu, "h"))),
        new Instruction(cpu, 0xB5, "or l", "Bitwise OR on a with l.", 1, 4, Instructions.or(cpu, new Register8(cpu, "l"))),
        new Instruction(cpu, 0xB6, "or (hl)", "Bitwise OR on a with (hl).", 1, 7, Instructions.or(cpu, new Indirect8(cpu, new Register16(cpu, "hl")))),
        new Instruction(cpu, 0xB7, "or a", "Bitwise OR on a with a.", 1, 4, Instructions.or(cpu, new Register8(cpu, "a"))),
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        new Instruction(cpu, 0xC0, "ret f_nz", "If condition cc is true, the top stack entry is popped into pc.", 1, 11, Instructions.ret(cpu, new FlagCondition(cpu, "zero", false))),
        new Instruction(cpu, 0xC1, "pop bc", "The memory location pointed to by sp is stored into c and sp is incremented. The memory location pointed to by sp is stored into b and sp is incremented again.", 1, 10, Instructions.pop(cpu, new Register16(cpu, "bc"))),
        new Instruction(cpu, 0xC2, "jp f_nz,**", "If condition cc is true, ** is copied to pc.", 3, 10, Instructions.jp(cpu, new FlagCondition(cpu, "zero", false), new Immediate16(cpu))),
        new Instruction(cpu, 0xC3, "jp **", "** is copied to pc.", 3, 10, Instructions.jp(cpu, new Immediate16(cpu))),
        new Instruction(cpu, 0xC4, "call f_nz,**", "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.", 3, 17, Instructions.call(cpu, new FlagCondition(cpu, "zero", false), new Immediate16(cpu))),
        new Instruction(cpu, 0xC5, "push bc", "sp is decremented and b is stored into the memory location pointed to by sp. sp is decremented again and c is stored into the memory location pointed to by sp.", 1, 11, Instructions.push(cpu, new Register16(cpu, "bc"))),
        new Instruction(cpu, 0xC6, "add a,*", "Adds * to a.", 2, 7, Instructions.add(cpu, new Register8(cpu, "a"), new Immediate8(cpu))),
        new Instruction(cpu, 0xC7, "rst 00h", "The current pc value plus one is pushed onto the stack, then is loaded with 00h.", 1, 11, Instructions.rst(cpu, new Fixed(0x00))),
        new Instruction(cpu, 0xC8, "ret f_z", "If condition cc is true, the top stack entry is popped into pc.", 1, 11, Instructions.ret(cpu, new FlagCondition(cpu, "zero", true))),
        new Instruction(cpu, 0xC9, "ret", "The top stack entry is popped into pc.", 1, 10, Instructions.ret(cpu)),
        new Instruction(cpu, 0xCA, "jp f_z,**", "If condition cc is true, ** is copied to pc.", 3, 10, Instructions.jp(cpu, new FlagCondition(cpu, "zero", true), new Immediate16(cpu))),
        null,
        new Instruction(cpu, 0xCC, "call f_z,**", "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.", 3, 17, Instructions.call(cpu, new FlagCondition(cpu, "zero", true), new Immediate16(cpu))),
        new Instruction(cpu, 0xCD, "call **", "The current pc value plus three is pushed onto the stack, then is loaded with **.", 3, 17, Instructions.call(cpu, new Immediate16(cpu))),
        new Instruction(cpu, 0xCE, "adc a,*", "Adds * and the carry flag to a.", 2, 7, Instructions.adc(cpu, new Register8(cpu, "a"), new Immediate8(cpu))),
        new Instruction(cpu, 0xCF, "rst 08h", "The current pc value plus one is pushed onto the stack, then is loaded with 08h.", 1, 11, Instructions.rst(cpu, new Fixed(0x08))),
        new Instruction(cpu, 0xD0, "ret f_nc", "If condition cc is true, the top stack entry is popped into pc.", 1, 11, Instructions.ret(cpu, new FlagCondition(cpu, "carry", false))),
        new Instruction(cpu, 0xD1, "pop de", "The memory location pointed to by sp is stored into e and sp is incremented. The memory location pointed to by sp is stored into d and sp is incremented again.", 1, 10, Instructions.pop(cpu, new Register16(cpu, "de"))),
        new Instruction(cpu, 0xD2, "jp f_nc,**", "If condition cc is true, ** is copied to pc.", 3, 10, Instructions.jp(cpu, new FlagCondition(cpu, "carry", false), new Immediate16(cpu))),
        null,
        new Instruction(cpu, 0xD4, "call f_nc,**", "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.", 3, 17, Instructions.call(cpu, new FlagCondition(cpu, "carry", false), new Immediate16(cpu))),
        new Instruction(cpu, 0xD5, "push de", "sp is decremented and d is stored into the memory location pointed to by sp. sp is decremented again and e is stored into the memory location pointed to by sp.", 1, 11, Instructions.push(cpu, new Register16(cpu, "de"))),
        new Instruction(cpu, 0xD6, "sub *", "Subtracts * from a.", 2, 7, Instructions.sub(cpu, new Immediate8(cpu))),
        new Instruction(cpu, 0xD7, "rst 10h", "The current pc value plus one is pushed onto the stack, then is loaded with 10h.", 1, 11, Instructions.rst(cpu, new Fixed(0x10))),
        new Instruction(cpu, 0xD8, "ret f_c", "If condition cc is true, the top stack entry is popped into pc.", 1, 11, Instructions.ret(cpu, new FlagCondition(cpu, "carry", true))),
        new Instruction(cpu, 0xD9, "exx", "Exchanges the 16-bit contents of bc, de, and hl with bc', de', and hl'.", 1, 4, Instructions.exx(cpu)),
        new Instruction(cpu, 0xDA, "jp f_c,**", "If condition cc is true, ** is copied to pc.", 3, 10, Instructions.jp(cpu, new FlagCondition(cpu, "carry", true), new Immediate16(cpu))),
        null,
        new Instruction(cpu, 0xDC, "call f_c,**", "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.", 3, 17, Instructions.call(cpu, new FlagCondition(cpu, "carry", true), new Immediate16(cpu))),
        null,
        new Instruction(cpu, 0xDE, "sbc a,*", "Subtracts * and the carry flag from a.", 2, 7, Instructions.sbc(cpu, new Register8(cpu, "a"), new Immediate8(cpu))),
        new Instruction(cpu, 0xDF, "rst 18h", "The current pc value plus one is pushed onto the stack, then is loaded with 18h.", 1, 11, Instructions.rst(cpu, new Fixed(0x18))),
        new Instruction(cpu, 0xE0, "ret f_np", "If condition cc is true, the top stack entry is popped into pc.", 1, 11, Instructions.ret(cpu, new FlagCondition(cpu, "parity", false))),
        new Instruction(cpu, 0xE1, "pop hl", "The memory location pointed to by sp is stored into l and sp is incremented. The memory location pointed to by sp is stored into h and sp is incremented again.", 1, 10, Instructions.pop(cpu, new Register16(cpu, "hl"))),
        new Instruction(cpu, 0xE2, "jp f_np,**", "If condition cc is true, ** is copied to pc.", 3, 10, Instructions.jp(cpu, new FlagCondition(cpu, "parity", false), new Immediate16(cpu))),
        new Instruction(cpu, 0xE3, "ex (sp),hl", "Exchanges (sp) with l, and (sp+1) with h.", 1, 19, Instructions.ex(cpu, new Indirect8(cpu, new Register16(cpu, "sp")), new Register16(cpu, "hl"))),
        new Instruction(cpu, 0xE4, "call f_np,**", "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.", 3, 17, Instructions.call(cpu, new FlagCondition(cpu, "parity", false), new Immediate16(cpu))),
        new Instruction(cpu, 0xE5, "push hl", "sp is decremented and h is stored into the memory location pointed to by sp. sp is decremented again and l is stored into the memory location pointed to by sp.", 1, 11, Instructions.push(cpu, new Register16(cpu, "hl"))),
        new Instruction(cpu, 0xE6, "and *", "Bitwise AND on a with *.", 2, 7, Instructions.and(cpu, new Immediate8(cpu))),
        new Instruction(cpu, 0xE7, "rst 20h", "The current pc value plus one is pushed onto the stack, then is loaded with 20h.", 1, 11, Instructions.rst(cpu, new Fixed(0x20))),
        new Instruction(cpu, 0xE8, "ret f_p", "If condition cc is true, the top stack entry is popped into pc.", 1, 11, Instructions.ret(cpu, new FlagCondition(cpu, "parity", true))),
        new Instruction(cpu, 0xE9, "jp (hl)", "Loads the value of hl into pc.", 1, 4, Instructions.jp(cpu, new Indirect16(cpu, new Register16(cpu, "hl")))),
        new Instruction(cpu, 0xEA, "jp f_p,**", "If condition cc is true, ** is copied to pc.", 3, 10, Instructions.jp(cpu, new FlagCondition(cpu, "parity", true), new Immediate16(cpu))),
        new Instruction(cpu, 0xEB, "ex de,hl", "Exchanges the 16-bit contents of de and hl.", 1, 4, Instructions.ex(cpu, new Register16(cpu, "de"), new Register16(cpu, "hl"))),
        new Instruction(cpu, 0xEC, "call f_p,**", "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.", 3, 17, Instructions.call(cpu, new FlagCondition(cpu, "parity", true), new Immediate16(cpu))),
        null,
        new Instruction(cpu, 0xEE, "xor *", "Bitwise XOR on a with *.", 2, 7, Instructions.xor(cpu, new Immediate8(cpu))),
        new Instruction(cpu, 0xEF, "rst 28h", "The current pc value plus one is pushed onto the stack, then is loaded with 28h.", 1, 11, Instructions.rst(cpu, new Fixed(0x28))),
        new Instruction(cpu, 0xF0, "ret f_ns", "If condition cc is true, the top stack entry is popped into pc.", 1, 11, Instructions.ret(cpu, new FlagCondition(cpu, "sign", false))),
        new Instruction(cpu, 0xF1, "pop af", "The memory location pointed to by sp is stored into f and sp is incremented. The memory location pointed to by sp is stored into a and sp is incremented again.", 1, 10, Instructions.pop(cpu, new Register16(cpu, "af"))),
        new Instruction(cpu, 0xF2, "jp f_ns,**", "If condition cc is true, ** is copied to pc.", 3, 10, Instructions.jp(cpu, new FlagCondition(cpu, "sign", false), new Immediate16(cpu))),
        new Instruction(cpu, 0xF3, "di", "Resets both interrupt flip-flops, thus prenting maskable interrupts from triggering.", 1, 4, Instructions.di(cpu)),
        new Instruction(cpu, 0xF4, "call f_ns,**", "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.", 3, 17, Instructions.call(cpu, new FlagCondition(cpu, "sign", false), new Immediate16(cpu))),
        new Instruction(cpu, 0xF5, "push af", "sp is decremented and a is stored into the memory location pointed to by sp. sp is decremented again and f is stored into the memory location pointed to by sp.", 1, 11, Instructions.push(cpu, new Register16(cpu, "af"))),
        new Instruction(cpu, 0xF6, "or *", "Bitwise OR on a with *.", 2, 7, Instructions.or(cpu, new Immediate8(cpu))),
        new Instruction(cpu, 0xF7, "rst 30h", "The current pc value plus one is pushed onto the stack, then is loaded with 30h.", 1, 11, Instructions.rst(cpu, new Fixed(0x30))),
        new Instruction(cpu, 0xF8, "ret f_s", "If condition cc is true, the top stack entry is popped into pc.", 1, 11, Instructions.ret(cpu, new FlagCondition(cpu, "sign", true))),
        new Instruction(cpu, 0xF9, "ld sp,hl", "Loads the value of hl into sp.", 1, 6, Instructions.ld(cpu, new Register16(cpu, "sp"), new Register16(cpu, "hl"))),
        new Instruction(cpu, 0xFA, "jp f_s,**", "If condition cc is true, ** is copied to pc.", 3, 10, Instructions.jp(cpu, new FlagCondition(cpu, "sign", true), new Immediate16(cpu))),
        new Instruction(cpu, 0xFB, "ei", "Sets both interrupt flip-flops, thus allowing maskable interrupts to occur. An interrupt will not occur until after the immediatedly following instruction.", 1, 4, Instructions.ei(cpu)),
        new Instruction(cpu, 0xFC, "call f_s,**", "If condition cc is true, the current pc value plus three is pushed onto the stack, then is loaded with **.", 3, 17, Instructions.call(cpu, new FlagCondition(cpu, "sign", true), new Immediate16(cpu))),
        null,
        null,
        new Instruction(cpu, 0xFF, "rst 38h", "The current pc value plus one is pushed onto the stack, then is loaded with 38h.", 1, 11, Instructions.rst(cpu, new Fixed(0x38)))
      };

      ed = new Instruction[] {
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        new Instruction(cpu, 0x42, "sbc hl,bc", "Subtracts bc and the carry flag from hl.", 2, 15, Instructions.sbc(cpu, new Register16(cpu, "hl"), new Register16(cpu, "bc"))),
        new Instruction(cpu, 0x43, "ld (**),bc", "Stores bc into the memory location pointed to by **.", 4, 20, Instructions.ld(cpu, new Indirect16(cpu, new Immediate16(cpu)), new Register16(cpu, "bc"))),
        null,
        null,
        new Instruction(cpu, 0x46, "im 0", "Sets interrupt mode 0.", 2, 8, Instructions.im(cpu, new Fixed(0))),
        new Instruction(cpu, 0x47, "ld i,a", "Stores the value of a into register i or r.", 2, 9, Instructions.ld(cpu, new Fixed(0), new Register8(cpu, "a"))),
        null,
        null,
        new Instruction(cpu, 0x4A, "adc hl,bc", "Adds bc and the carry flag to hl.", 2, 15, Instructions.adc(cpu, new Register16(cpu, "hl"), new Register16(cpu, "bc"))),
        new Instruction(cpu, 0x4B, "ld bc,(**)", "Loads the value pointed to by ** into bc.", 4, 20, Instructions.ld(cpu, new Register16(cpu, "bc"), new Indirect16(cpu, new Immediate16(cpu)))),
        null,
        null,
        new Instruction(cpu, 0x4E, "im 0/1", "Sets undefined interrupt mode 0/1.", 2, 8, Instructions.im(cpu, new Fixed(0))),
        new Instruction(cpu, 0x4F, "ld r,a", "Stores the value of a into register i or r.", 2, 9, Instructions.ld(cpu, new Fixed(0), new Register8(cpu, "a"))),
        null,
        null,
        new Instruction(cpu, 0x52, "sbc hl,de", "Subtracts de and the carry flag from hl.", 2, 15, Instructions.sbc(cpu, new Register16(cpu, "hl"), new Register16(cpu, "de"))),
        new Instruction(cpu, 0x53, "ld (**),de", "Stores de into the memory location pointed to by **.", 4, 20, Instructions.ld(cpu, new Indirect16(cpu, new Immediate16(cpu)), new Register16(cpu, "de"))),
        null,
        null,
        new Instruction(cpu, 0x56, "im 1", "Sets interrupt mode 1.", 2, 8, Instructions.im(cpu, new Fixed(1))),
        new Instruction(cpu, 0x57, "ld a,i", "Stores the value of register i or r into a.", 2, 9, Instructions.ld(cpu, new Register8(cpu, "a"), new Fixed(0))),
        null,
        null,
        new Instruction(cpu, 0x5A, "adc hl,de", "Adds de and the carry flag to hl.", 2, 15, Instructions.adc(cpu, new Register16(cpu, "hl"), new Register16(cpu, "de"))),
        new Instruction(cpu, 0x5B, "ld de,(**)", "Loads the value pointed to by ** into de.", 4, 20, Instructions.ld(cpu, new Register16(cpu, "de"), new Indirect16(cpu, new Immediate16(cpu)))),
        null,
        null,
        new Instruction(cpu, 0x5E, "im 2", "Sets interrupt mode 2.", 2, 8, Instructions.im(cpu, new Fixed(2))),
        new Instruction(cpu, 0x5F, "ld a,r", "Stores the value of register i or r into a.", 2, 9, Instructions.ld(cpu, new Register8(cpu, "a"), new Fixed(0))),
        null,
        null,
        new Instruction(cpu, 0x62, "sbc hl,hl", "Subtracts hl and the carry flag from hl.", 2, 15, Instructions.sbc(cpu, new Register16(cpu, "hl"), new Register16(cpu, "hl"))),
        new Instruction(cpu, 0x63, "ld (**),hl", "Stores hl into the memory location pointed to by **.", 4, 20, Instructions.ld(cpu, new Indirect16(cpu, new Immediate16(cpu)), new Register16(cpu, "hl"))),
        null,
        null,
        new Instruction(cpu, 0x66, "im 0", "Sets interrupt mode 0.", 2, 8, Instructions.im(cpu, new Fixed(0))),
        null,
        null,
        null,
        new Instruction(cpu, 0x6A, "adc hl,hl", "Adds hl and the carry flag to hl.", 2, 15, Instructions.adc(cpu, new Register16(cpu, "hl"), new Register16(cpu, "hl"))),
        new Instruction(cpu, 0x6B, "ld hl,(**)", "Loads the value pointed to by ** into hl.", 4, 20, Instructions.ld(cpu, new Register16(cpu, "hl"), new Indirect16(cpu, new Immediate16(cpu)))),
        null,
        null,
        new Instruction(cpu, 0x6E, "im 0/1", "Sets undefined interrupt mode 0/1.", 2, 8, Instructions.im(cpu, new Fixed(0))),
        null,
        null,
        null,
        new Instruction(cpu, 0x72, "sbc hl,sp", "Subtracts hl and the carry flag from hl.", 2, 15, Instructions.sbc(cpu, new Register16(cpu, "hl"), new Register16(cpu, "sp"))),
        new Instruction(cpu, 0x73, "ld (**),sp", "Stores sp into the memory location pointed to by **.", 4, 20, Instructions.ld(cpu, new Indirect16(cpu, new Immediate16(cpu)), new Register16(cpu, "sp"))),
        null,
        null,
        new Instruction(cpu, 0x76, "im 1", "Sets interrupt mode 1.", 2, 8, Instructions.im(cpu, new Fixed(1))),
        null,
        null,
        null,
        new Instruction(cpu, 0x7A, "adc hl,sp", "Adds hl and the carry flag to hl.", 2, 15, Instructions.adc(cpu, new Register16(cpu, "hl"), new Register16(cpu, "sp"))),
        new Instruction(cpu, 0x7B, "ld sp,(**)", "Loads the value pointed to by ** into sp.", 4, 20, Instructions.ld(cpu, new Register16(cpu, "sp"), new Indirect16(cpu, new Immediate16(cpu)))),
        null,
        null,
        new Instruction(cpu, 0x7E, "im 2", "Sets interrupt mode 2.", 2, 8, Instructions.im(cpu, new Fixed(2))),
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        new Instruction(cpu, 0xA0, "ldi", "Transfers a byte of data from the memory location pointed to by hl to the memory location pointed to by de. Then hl and de are incremented and bc is decremented.", 2, 16, Instructions.ldi(cpu)),
        new Instruction(cpu, 0xA1, "cpi", "Compares the value of the memory location pointed to by hl with a. Then hl is incremented and bc is decremented.", 2, 16, Instructions.cpi(cpu)),
        new Instruction(cpu, 0xA2, "ini", "A byte from port c is written to the memory location pointed to by hl. Then hl is incremented and b is decremented.", 2, 16, Instructions.ini(cpu)),
        new Instruction(cpu, 0xA3, "outi", "A byte from the memory location pointed to by hl is written to port c. Then hl is incremented and b is decremented.", 2, 16, Instructions.outi(cpu)),
        null,
        null,
        null,
        null,
        new Instruction(cpu, 0xA8, "ldd", "Transfers a byte of data from the memory location pointed to by hl to the memory location pointed to by de. Then hl, de, and bc are decremented.", 2, 16, Instructions.ldd(cpu)),
        new Instruction(cpu, 0xA9, "cpd", "Compares the value of the memory location pointed to by hl with a. Then hl and bc are decremented.", 2, 16, Instructions.cpd(cpu)),
        new Instruction(cpu, 0xAA, "ind", "A byte from port c is written to the memory location pointed to by hl. Then hl and b are decremented.", 2, 16, Instructions.ind(cpu)),
        new Instruction(cpu, 0xAB, "outd", "A byte from the memory location pointed to by hl is written to port c. Then hl and b are decremented.", 2, 16, Instructions.outd(cpu)),
        null,
        null,
        null,
        null,
        new Instruction(cpu, 0xB0, "ldir", "Transfers a byte of data from the memory location pointed to by hl to the memory location pointed to by de. Then hl and de are incremented and bc is decremented. If bc is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.", 2, 21, Instructions.ldir(cpu)),
        new Instruction(cpu, 0xB1, "cpir", "Compares the value of the memory location pointed to by hl with a. Then hl is incremented and bc is decremented. If bc is not zero and z is not set, this operation is repeated. Interrupts can trigger while this instruction is processing.", 2, 21, Instructions.cpir(cpu)),
        new Instruction(cpu, 0xB2, "inir", "A byte from port c is written to the memory location pointed to by hl. Then hl is incremented and b is decremented. If b is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.", 2, 21, Instructions.inir(cpu)),
        new Instruction(cpu, 0xB3, "otir", "A byte from the memory location pointed to by hl is written to port c. Then hl is incremented and b is decremented. If b is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.", 2, 21, Instructions.otir(cpu)),
        null,
        null,
        null,
        null,
        new Instruction(cpu, 0xB8, "lddr", "Transfers a byte of data from the memory location pointed to by hl to the memory location pointed to by de. Then hl, de, and bc are decremented. If bc is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.", 2, 21, Instructions.lddr(cpu)),
        new Instruction(cpu, 0xB9, "cpdr", "Compares the value of the memory location pointed to by hl with a. Then hl and bc are decremented. If bc is not zero and z is not set, this operation is repeated. Interrupts can trigger while this instruction is processing.", 2, 21, Instructions.cpdr(cpu)),
        new Instruction(cpu, 0xBA, "indr", "A byte from port c is written to the memory location pointed to by hl. Then hl and b are decremented. If b is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.", 2, 21, Instructions.indr(cpu)),
        new Instruction(cpu, 0xBB, "otdr", "A byte from the memory location pointed to by hl is written to port c. Then hl and b are decremented. If b is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.", 2, 21, Instructions.otdr(cpu)),
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
      };

        // GENERATED CODE ENDS HERE
    }
  }

}
